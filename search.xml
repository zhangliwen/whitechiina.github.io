<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>移动web适配之rem</title>
      <link href="/2019/11/18/%E7%A7%BB%E5%8A%A8web%E9%80%82%E9%85%8D%E4%B9%8Brem/"/>
      <url>/2019/11/18/%E7%A7%BB%E5%8A%A8web%E9%80%82%E9%85%8D%E4%B9%8Brem/</url>
      
        <content type="html"><![CDATA[<h3 id="移动web开发适配方案之Rem"><a href="#移动web开发适配方案之Rem" class="headerlink" title="移动web开发适配方案之Rem"></a>移动web开发适配方案之Rem</h3><p>移动端为什么要做适配?<br>移动端相对PC端来说大部分浏览器内核都是基于Webkit的，所以大部分都支持CSS3的最新语法。但是由于手机的屏幕尺寸和分辨率都不太一样（尤其是安卓），所以不得不对不同分辨率的手机做适配来达到近似的展示效果。</p><p>一般来说，UI只会给我们提供一份设计图，目前比较多的是参考手机淘宝的方案给一份750px宽的设计稿，而我们前端要做的就是在不同分辨率的手机上以同样的效果展示这份设计稿。</p><p>在讲适配方案之前，有几个基本的移动端开始相关的知识点得了解一下:</p><ol><li>rem单位: 说到rem这个单位就不得不提一下在它之前出现的一个类似单位em，em时相对于父级font-size的相对单位，而rem是相对于根节点html的相对单位，也就是说，当html的font-size为12px时，某一个元素的font-size设为1rem也就是等同于12px了。正因为rem单位的这一特性，从而让它可以成为移动端适配的一个关键单位。</li><li>vw单位：相对于视窗的宽度，视窗宽度是100vw，与整个单位类似的是wh,就是视窗高度，视窗高度时100vh。更详细的特性可以参考视区相关单位vw, vh..简介以及可实际应用场景</li></ol><ul><li>物理像素: 也可以说是设备无关像素，例如iPhone6的分辨率（750x1334）指的是物理像素</li><li>逻辑像素: 是浏览器使用的抽象单位，状态是可变的，例如在PC浏览器调试面板上我们可以看到iPhone6的物理像素为(375x667)</li><li>物理像素与逻辑像素的关系就是设备像素缩放比dpr<h3 id="适配思路"><a href="#适配思路" class="headerlink" title="适配思路"></a>适配思路</h3></li></ul><ol><li>使用CSS的@media媒体查询设置在不同屏幕尺寸下现实不同的效果，类似于这样：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">首先，这样只照顾了固定分辨率的机型，肯定是不够的，而且，如果针对页面上的每一个元素写这么多套适配也不现实，媒体查询还是比较适合<span class="selector-tag">PC</span>端不同分辨率屏幕之间的适配。</span><br><span class="line"></span><br><span class="line">2. 使用<span class="selector-tag">css</span>的单位<span class="selector-tag">rem</span>，类似于这样：</span><br><span class="line"></span><br><span class="line">```<span class="selector-tag">html</span></span><br><span class="line">@<span class="keyword">media</span> only screen and (min-width: <span class="number">375px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size </span>: <span class="number">62.5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> only screen and (min-width: <span class="number">360px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size </span>: <span class="number">60px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>当然，在实际开发中不可能真的这样去写，既然上面已经提到了rem这一单位的特性，那么我们要做的就是根据不同分辨率的设备动态地改变html的font-size就好，也就是1rem代表的大小。比较常见的有两种方案：</p><p>通过js动态获取屏幕的宽度，从而计算出html的font-size，还是拿日常开发常见的750px的设计稿为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> htmlWidth = <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line"><span class="keyword">let</span> htmlDOM = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'html'</span>)[<span class="number">0</span>];</span><br><span class="line">htmlDOM.style.fontSize = htmlWidth / <span class="number">7.5</span> + <span class="string">'px'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> htmlWidth = <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">  htmlDOM.style.fontSize = htmlWidth / <span class="number">7.5</span> + <span class="string">'px'</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样一来，在375px宽的设备下，html的font-size就是50px,为什么要除以7.5呢，因为这样设计稿上的数值与需要得到的rem值正好是100倍的关系，这样便于换算，当然，引入了scss等预处理工具之后，取多少都不重要了，反正用一个处理函数统一转化一下就可以了,当html的font-size是37.5的时候：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function"><span class="keyword">function</span> <span class="title">px2rem</span> (<span class="params">$px</span>) </span>&#123;</span><br><span class="line">    $rem: <span class="number">75</span>;</span><br><span class="line">    @<span class="keyword">return</span> ($px / $rem) + rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方案同样是通过vw这一单位实现rem适配<br>上面那种方案说白了就是通过JS动态改变html的font-size的大小，而现在有这么一种单位本身的大小就会随着屏幕的变化而变化，那岂不是省去了JS操作Html字体大小的代码！<br>我最开始有点担心的是兼容性，不过从caniuse上查的的兼容性上来看兼容性还是比较高的，安卓版本大于4.0的浏览器都是兼容的的。尤其对于在微信上使用的H5页面是完全不用担心兼容性问题的<br>具体实现如下：<br>/*<br> 当在Ip6下时，100vw代表375px,而视觉稿一般是750px,为了方便算，当html上的1rem代表50px时，<br> 视觉稿上的像素跟rem就存在了100倍的转化关闭，而此时1vw代表是3.75px，所以html上的font-siez为50/3.75，<br> 约等于13.33333vw,这样即使不用scss也是比较利于换算的<br> */</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html &#123;background-color: #eee; font-size: 13.33333vw;&#125;</span><br></pre></td></tr></table></figure><p>设为上面这样一个数值同样是为了计算方便，当然不是必须的，在这样一个数值下，相对应的元素除以100就可以了，写成scss方法如下</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@function px (<span class="variable">$px</span>) &#123; @return (<span class="variable">$px</span> / 100) + rem; &#125; <span class="selector-class">.demo2</span> &#123;<span class="attribute">width</span>: px(<span class="number">200</span>); <span class="attribute">height</span>: px(<span class="number">200</span>); <span class="attribute">background-color</span>: <span class="number">#ddd</span>;&#125;</span><br></pre></td></tr></table></figure><p>我看了一下网易新闻的h5页面目前就是使用的这种方案</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最开始想写这篇文章是因为之前只知道通过JS动态调节html的font-size这么一种适配方案，刚好前段时间接触到了公司的一个移动端项目，我只是单独开发几个页面，但我发现是用的vw单位实现的rem方案，刚开始还觉得蛮新奇的，其实后来查资料仔细一想，跟JS那种方案本质上并没有什么区别，都是以屏幕宽度作为底，动态地调节了html的font-size，也就是1rem的大小。</p><p>为了写这篇文章又回看了慕课网上这个视频：移动web开发适配秘籍Rem,真的挺感谢这些大牛无私分享的。就像他所说的，移动web开发适配的方案有许多，然而最好的方案一定要掌握。Rem适配方案是我目前所看到的的使用的最多的，多多了解这种方法背后的原理和熟练掌握这种方法还是挺重要的，再次感谢这些大牛的精彩分享，希望我的总结在提升自己的同时也能帮到别人！</p><p>参考文章：<br><a href="https://github.com/CruxF/IMOOC/issues/4" target="_blank" rel="noopener">Hello，移动web基础知识整理</a></p><p><a href="https://github.com/CruxF/IMOOC/issues/3" target="_blank" rel="noopener">移动web开发适配秘籍Rem</a><br><a href="https://github.com/sunmaobin/sunmaobin.github.io/issues/28" target="_blank" rel="noopener">移动端H5解惑-页面适配（二）</a><br><a href="https://github.com/amfe/article/issues/17" target="_blank" rel="noopener">使用Flexible实现手淘H5页面的终端适配</a><br><a href="https://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/" target="_blank" rel="noopener">视区相关单位vw, vh..简介以及可实际应用场景</a></p>]]></content>
      
      
      <categories>
          
          <category> Web概述 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown的常用语法</title>
      <link href="/2019/11/18/Markdown%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/11/18/Markdown%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>自从博客转移到github上之后，现在写博客都需要用到Markdown语法。<br>于是有了这边博文，方便以后查阅。</p><h3 id="了解-Markdown"><a href="#了解-Markdown" class="headerlink" title="了解 Markdown"></a>了解 Markdown</h3><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p><h3 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a>1. 斜体和粗体</h3><p>使用 <em>和 *</em> 表示斜体和粗体。</p><p>示例：</p><p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p><h3 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a>2. 分级标题</h3><p>在行首加井号表示不同级别的标题 (H1-H6)。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</span><br></pre></td></tr></table></figure><h3 id="3-外链接"><a href="#3-外链接" class="headerlink" title="3. 外链接"></a>3. 外链接</h3><p>使用 <a href="链接地址">描述</a> 为文字增加外链接。</p><p>示例：</p><p>这是去往 <a href="http://oyjt.github.io/" target="_blank" rel="noopener">本人博客</a> 的链接。</p><h3 id="4-无序列表"><a href="#4-无序列表" class="headerlink" title="4. 无序列表"></a>4. 无序列表</h3><p>使用 *，- 表示无序列表。</p><p>示例：</p><ul><li>无序列表项 一</li><li>无序列表项 二</li><li>无序列表项 三</li></ul><h3 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. 有序列表</h3><p>使用数字和点表示有序列表。</p><p>示例：</p><ol><li>有序列表项 一</li><li>有序列表项 二</li><li>有序列表项 三</li></ol><h3 id="6-文字引用"><a href="#6-文字引用" class="headerlink" title="6. 文字引用"></a>6. 文字引用</h3><p>使用 &gt; 表示文字引用。</p><p>示例：</p><blockquote><p>野火烧不尽，春风吹又生。</p></blockquote><h3 id="7-行内代码块"><a href="#7-行内代码块" class="headerlink" title="7. 行内代码块"></a>7. 行内代码块</h3><p>使用 <code>代码</code> 表示行内代码块。</p><p>示例：</p><p>让我们聊聊 <code>html</code>。</p><h3 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8. 代码块"></a>8. 代码块</h3><p>使用 四个缩进空格 表示代码块。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个代码块，此行左侧有四个不可见的空格。</span><br></pre></td></tr></table></figure><h3 id="9-插入图像"><a href="#9-插入图像" class="headerlink" title="9. 插入图像"></a>9. 插入图像</h3><p>使用 <img src="C:/Users/Administrator/Desktop/%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80" alt="描述"> 插入图像。</p><p>示例：</p><p><a href="https://www.zybuluo.com/static/img/my_head.jpg" target="_blank" rel="noopener"><img src="https://www.zybuluo.com/static/img/my_head.jpg" alt="我的头像"></a></p><h3 id="10-删除线"><a href="#10-删除线" class="headerlink" title="10. 删除线"></a>10. 删除线</h3><p>使用 ~~ 表示删除线。</p><p><del>这是一段错误的文本。</del></p><h3 id="11-加强的代码块"><a href="#11-加强的代码块" class="headerlink" title="11. 加强的代码块"></a>11. 加强的代码块</h3><p>支持四十一种编程语言的语法高亮的显示。</p><p>非代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install vim-gnome</span><br></pre></td></tr></table></figure><p>Python 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@requires_authorizationdef somefunc(param1=&apos;&apos;, param2=0):    &apos;&apos;&apos;A docstring&apos;&apos;&apos;    if param1 &gt; param2: # interesting        print &apos;Greater&apos;    return (param2 - param1 + 1) or Noneclass SomeClass:    pass&gt;&gt;&gt; message = &apos;&apos;&apos;interpreter... prompt&apos;&apos;&apos;</span><br></pre></td></tr></table></figure><p>JavaScript 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123;  var a = 1, b = 1;  var tmp;  while (--n &gt;= 0) &#123;    tmp = a;    a += b;    b = tmp;  &#125;  return a;&#125;document.write(fib(10));</span><br></pre></td></tr></table></figure><h3 id="12-表格支持"><a href="#12-表格支持" class="headerlink" title="12. 表格支持"></a>12. 表格支持</h3><table><thead><tr><th align="left">项目</th><th align="right">价格</th><th align="center">数量</th></tr></thead><tbody><tr><td align="left">计算机</td><td align="right">$1600</td><td align="center">5</td></tr><tr><td align="left">手机</td><td align="right">$12</td><td align="center">12</td></tr><tr><td align="left">管线</td><td align="right">$1</td><td align="center">234</td></tr></tbody></table><h3 id="13-待办事宜-Todo-列表"><a href="#13-待办事宜-Todo-列表" class="headerlink" title="13. 待办事宜 Todo 列表"></a>13. 待办事宜 Todo 列表</h3><p>注：本博客不支持<br>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- [ ] **七月旅行准备**</span><br><span class="line">    - [ ] 准备邮轮上需要携带的物品</span><br><span class="line">    - [ ] 浏览日本免税店的物品</span><br><span class="line">    - [x] 购买蓝宝石公主号七月一日的船票</span><br></pre></td></tr></table></figure><p>对应显示如下待办事宜 Todo 列表：</p><ul><li><input disabled="" type="checkbox"> <strong>七月旅行准备</strong><ul><li><input disabled="" type="checkbox"> 准备邮轮上需要携带的物品</li><li><input disabled="" type="checkbox"> 浏览日本免税店的物品</li><li><input checked="" disabled="" type="checkbox"> 购买蓝宝石公主号七月一日的船票</li></ul></li></ul><p>参考资料：<br><a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="noopener">Markdown 简明语法</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端面试之html5新特性</title>
      <link href="/2019/11/17/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8Bhtml5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/11/17/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8Bhtml5%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>今天来谈谈前端面试中基本上每次一面的时候都会被问到的一个问题，那就是html5的新特性。这个是学习前端必须掌握的基础知识。</p><h2 id="新增的元素"><a href="#新增的元素" class="headerlink" title="新增的元素"></a>新增的元素</h2><p>html5新增了一些语义化更好的标签元素。</p><h4 id="结构元素"><a href="#结构元素" class="headerlink" title="结构元素"></a>结构元素</h4><p>article元素，表示页面中的一块与上下文不相关的独立内容，比如博客中的一篇文章。<br>aside元素，表示article内容之外的内容，辅助信息。<br>header元素，表示页面中一个内容区块或整个页面的页眉。<br>hgroup元素，用于对页面中一个区块或整个页面的标题进行组合。<br>footer元素，表示页面中一个内容区块或整个页面的页脚。<br>figure元素，表示媒介内容的分组，以及它们的标题。<br>section元素，表示页面中一个内容区块，比如章节。<br>nav元素，表示页面中的导航链接。</p><h4 id="其他元素"><a href="#其他元素" class="headerlink" title="其他元素"></a>其他元素</h4><p>video元素，用来定义视频。<br>audio元素，用来定义音频。<br>canvas元素，用来展示图形，该元素本身没有行为，仅提供一块画布。<br>embed元素，用来插入各种多媒体，格式可以是Midi、Wav、AIFF、AU、MP3等。<br>mark元素，用来展示高亮的文字。<br>progress元素，用来展示任何类型的任务的进度。<br>meter元素，表示度量衡，定义预定义范围内的度量。<br>time元素，用来展示日期或者时间。<br>command元素，表示命令按钮。<br>details元素，用来展示用户要求得到并且可以得到的细节信息。<br>summary元素，用来为details元素定义可见的标题。<br>datalist元素，用来展示可选的数据列表，与input元素配合使用，可以制作出输入值的下拉列表。<br>datagrid元素，也用来展示可选的数据列表，以树形列表的形式来显示。<br>keygen元素，表示生成密匙。<br>output元素，表示不同类型的输出。<br>source元素，为媒介元素定义媒介资源。<br>m enu 元素，表示菜单列表。<br>ruby元素，表示ruby注释， rt元素表示字符的解释或发音。 rp元素在ruby注释中使用，以定义不支持ruby元素的浏览器所显示的内容。<br>wbr元素，表示软换行。与br元素的区别是：br元素表示此处必须换行，而wbr元素的意思是浏览器窗口或父级元素的宽度够宽时。不进行换行，而当宽度不够时，主动在此处进行换行。<br>bdi元素，定义文本的文本方向，使其脱离其周围文本的方向设置。<br>dialog元素，表示对话框或窗口。</p><h2 id="废除的元素"><a href="#废除的元素" class="headerlink" title="废除的元素"></a>废除的元素</h2><p>html5中废除了一些纯表现的元素，只有部分浏览器支持的元素还有一些会对可用性产生负面影响的元素。</p><h4 id="纯表现元素"><a href="#纯表现元素" class="headerlink" title="纯表现元素"></a>纯表现元素</h4><p>纯表现的元素就是那些可以用css替代的元素。basefont、big、center、font、s、strike、tt、u这些元素，他们的功能都是纯粹为页面展示服务的，html5提倡把页面展示性功能放在css样式表中统一处理，所以将这些元素废除，用css样式进行替代。</p><h4 id="对可用性产生负面影响的元素"><a href="#对可用性产生负面影响的元素" class="headerlink" title="对可用性产生负面影响的元素"></a>对可用性产生负面影响的元素</h4><p>对于frameset元素、frame元素与noframes元素，由于frame框架对网页可用性存在负面影响，在html5中已不支持frame框架，只支持iframe框架，html5中同时将frameset、frame和noframes这三个元素废除。</p><h4 id="只有部分浏览器支持的元素"><a href="#只有部分浏览器支持的元素" class="headerlink" title="只有部分浏览器支持的元素"></a>只有部分浏览器支持的元素</h4><p>对于applet、bgsound、blink、marquee等元素，由于只有部分浏览器支持，特别是bgsound元素以及marquee元素，只被IE支持，所以在html5中被废除。其中applet元素可由embed元素或object元素替代，bgsound元素可由audio元素替代，marquee可以由javascript编程的方式替代。</p><h2 id="新增的API"><a href="#新增的API" class="headerlink" title="新增的API"></a>新增的API</h2><h4 id="Canvas-API"><a href="#Canvas-API" class="headerlink" title="Canvas API"></a>Canvas API</h4><p>上文提到的canvas元素可以为页面提供一块画布来展示图形。结合Canvas API，就可以在这块画布上动态生成和展示各种图形、图表、图像以及动画了。Canvas本质上是位图画布，不可缩放，绘制出来的对象不属于页面DOM结构或者任何命名空间。不需要将每个图元当做对象存储，执行性能非常好。</p><p>利用Canvas API进行绘图，首先要获取canvas元素的上下文，然后用该上下文中封装的各种绘图功能进行绘图。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span>&gt;</span>替代内容<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> context =canvas.getContext(<span class="string">"2d"</span>); <span class="comment">// 获取上下文</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//设置纯色</span></span></span><br><span class="line"><span class="actionscript">    context.fillStyle = <span class="string">"red"</span>;</span></span><br><span class="line"><span class="actionscript">    context.strokeStyle = <span class="string">"blue"</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 实践表明在不设置fillStyle下的默认fillStyle为black</span></span></span><br><span class="line">    context.fillRect(0, 0, 100, 100);</span><br><span class="line"><span class="actionscript">    <span class="comment">// 实践表明在不设置strokeStyle下的默认strokeStyle为black</span></span></span><br><span class="line">    context.strokeRect(120, 0, 100, 100);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><p>SVG是html5的另一项图形功能，它是一种标准的矢量图形，是一种文件格式，有自己的API。html5引入了内联SVG，使得SVG元素可以直接出现在html标记中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">height</span>=<span class="string">100</span> <span class="attr">width</span>=<span class="string">100</span>&gt;</span><span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">50</span> <span class="attr">cy</span>=<span class="string">50</span> <span class="attr">r</span>=<span class="string">50</span> /&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="音频和视频"><a href="#音频和视频" class="headerlink" title="音频和视频"></a>音频和视频</h2><p>audio和video元素的出现让html5的媒体应用多了新选择，开发人员不必使用插件就能播放音频和视频。对于这两个元素，html5规范提供了通用、完整、可脚本化控制的API。<br>html5规范出来之前，在页面中播放视频的典型方式是使用Flash、QuickTime或者Windows Media插件往html中嵌入音频视频，相对这种方式，使用html5的媒体标签有两大好处。</p><p>作为浏览器原生支持的功能，新的audio和video元素无需安装。<br>媒体元素想Web页面提供了通用、集成和可脚本化控制的API。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"video.webm"</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">"videoplayer.swf"</span> <span class="attr">type</span>=<span class="string">"application/x-shockwave-flash"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"movie"</span> <span class="attr">value</span>=<span class="string">"video.swf"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line">    Your browser does not support HTML5 video.</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="浏览器支持性检测"><a href="#浏览器支持性检测" class="headerlink" title="浏览器支持性检测"></a>浏览器支持性检测</h2><p>浏览器检测是否支持audio元素或者video元素最简单的方式是用脚本动态创建它，然后检测特定函数是否存在。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasVideo = !!(<span class="built_in">document</span>.createElement(<span class="string">'video'</span>).canPlayType);</span><br><span class="line">Geolocation API</span><br></pre></td></tr></table></figure><p>html5的Geolocation API（地理定位API），可以请求用户共享他们的位置。使用方法非常简单，如果用户同意，浏览器就会返回位置信息，该位置信息是通过支持html5地理定位功能的底层设备（如笔记本电脑或手机）提供给浏览器的。位置信息由纬度、经度坐标和一些其他元数据组成。</p><h3 id="位置信息从何而来"><a href="#位置信息从何而来" class="headerlink" title="位置信息从何而来"></a>位置信息从何而来</h3><p>Geolocation API不指定设备使用哪种底层技术来定位应用程序的用户。相反，它只是用于检索位置信息的API，而且通过该API检索到的数据只具有某种程度的准确性，并不能保证设备返回的位置是精确的。设备可以使用下列数据源：</p><p>IP地址<br>三维坐标<br>GPS<br>从RFID、WiFi和蓝牙到WiFi的MAC地址<br>GSM或CDMA手机的ID<br>用户自定义数据<br>使用方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次更新</span></span><br><span class="line">navigator.geolocation.getCurrentPosition(updateLocation, handleLocationEror);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateLocation</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> latitude = position.coords.latitude;     <span class="comment">// 纬度</span></span><br><span class="line">    <span class="keyword">var</span> longitude = position.coords.longitude;   <span class="comment">// 经度</span></span><br><span class="line">    <span class="keyword">var</span> accuracy = position.coords.accuracy;     <span class="comment">// 准确度</span></span><br><span class="line">    <span class="keyword">var</span> timestamp = position.coords.timestamp;   <span class="comment">// 时间戳</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleLocationEror</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重复更新</span></span><br><span class="line">navigator.geolocation.watchPosition(updateLocation, handleLocationEror);</span><br><span class="line"><span class="comment">// 不再接受位置更新</span></span><br><span class="line">navigator.geolocation.clearWatch(watchId);</span><br></pre></td></tr></table></figure><h2 id="Communication-API"><a href="#Communication-API" class="headerlink" title="Communication API"></a>Communication API</h2><p>跨文档消息传递<br>出于安全方面的考虑，运行在同一浏览器中的框架、标签页、窗口间的通信一直都受到了严格的限制。然而，现实中存在一些合理的让不同站点的内容能在浏览器内进行交互的需求。这种情形下，如果浏览器内部能提供直接的通信机制，就能更好地组织这些应用。<br>html5中引入了一种新功能，跨文档消息通信，可以确保iframe、标签页、窗口间安全地进行跨源通信。postMessage API为发送消息的标准方式，发送消息非常简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.postMessage(<span class="string">'Hello, world'</span>, <span class="string">'http://www.example.com/'</span>);</span><br></pre></td></tr></table></figure><p>接收消息时，仅需在页面中增加一个事件处理函数。当某个消息到达时，通过检查消息的来源来决定是否对这条消息进行处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, messageHandler, <span class="literal">true</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">messageHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(e.origin) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"friend.example.com"</span>:</span><br><span class="line">        <span class="comment">// 处理消息</span></span><br><span class="line">        processMessage(e.data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        <span class="comment">// 消息来源无法识别</span></span><br><span class="line">        <span class="comment">// 消息被忽略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息事件是一个拥有data(数据)和origin(源)属性的DOM事件。data属性是发送方传递的实际消息，而origin属性是发送来源。</p><h5 id="XMLHttpRequest-Level2"><a href="#XMLHttpRequest-Level2" class="headerlink" title="XMLHttpRequest Level2"></a>XMLHttpRequest Level2</h5><p>XMLHttpRequest API使得Ajax技术成为可能，作为XMLHttpRequest的改进版，XMLHttpRequest Level2在功能上有了很大的改进。主要两个方面：</p><p>跨源XMLHttpRequest<br>进度事件<br>跨源XMLHttpRequest<br>过去，XMLHttpRequest仅限于同源通信，XMLHttpRequest Level2通过CORS实现了跨源XMLHttpRequest。跨源HTTP请求包含一个Origin头部，它为服务器提供HTTP请求的源信息。</p><h2 id="WebSockets-API"><a href="#WebSockets-API" class="headerlink" title="WebSockets API"></a>WebSockets API</h2><p>WebSockets是html5中最强大的通信功能，它定义了一个全双工通信信道，仅通过Web上的一个Socket即可进行通信。</p><h4 id="WebSockets握手"><a href="#WebSockets握手" class="headerlink" title="WebSockets握手"></a>WebSockets握手</h4><p>为了建立WebSockets通信，客户端和服务器在初始握手时，将HTTP协议升级到WebSocket协议。一旦连接建立成功，就可以在全双工模式下在客户端和服务器之间来回传递WebSocket消息。</p><h4 id="WebSockets接口"><a href="#WebSockets接口" class="headerlink" title="WebSockets接口"></a>WebSockets接口</h4><p>除了对WebSockets协议定义外，该规范还同时定义了用于JavaScript应用程序的WebSocket接口。WebSockets接口的使用很简单。要连接远程主机，只需要新建一个WebSocket实例，提供希望连接的对端URL。</p><h2 id="Forms-API"><a href="#Forms-API" class="headerlink" title="Forms API"></a>Forms API</h2><h4 id="新表单元素"><a href="#新表单元素" class="headerlink" title="新表单元素"></a>新表单元素</h4><p>tel元素，表示电话号码。<br>email元素，表示电子邮件地址文本框。<br>url元素，表示网页的url。<br>search元素，用于搜索引擎，比如在站点顶部显示的搜索框。<br>range元素，特定值范围内的数值选择器，典型的显示方式是滑动条。<br>number元素，只包含数值的字段。</p><h4 id="未来的表单元素"><a href="#未来的表单元素" class="headerlink" title="未来的表单元素"></a>未来的表单元素</h4><p>color元素，颜色选择器，基于调色盘或者取色板进行选择。<br>datetime元素，显示完整的日期和时间，包括时区。<br>datetime-local，显示日期和时间。<br>time元素，不含时区的时间选择器和指示器。<br>date元素，日期选择器。<br>week元素，某年中的周选择器。<br>month元素，某年中的月选择器。</p><h4 id="新的表单特性和函数"><a href="#新的表单特性和函数" class="headerlink" title="新的表单特性和函数"></a>新的表单特性和函数</h4><p>placeholder<br>当用户还没输入值的时候，输入型控件可以通过placeholder特性向用户显示描述性说明或者提示信息。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">placeholder</span>=<span class="string">"First and last name"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>autocomplete<br>浏览器通过autocomplete特性能够知晓是否应该保存输入值以备将来使用。</p><p>autofocus<br>通过autofocus特性可以指定某个表单元素获得输入焦点，每个页面上只允许出现一个autofocus特性，如果设置了多个，则相当于未指定此行为。</p><p>spellcheck<br>可对带有文本内容的输入控件和textarea空间控制spellcheck属性。设置完后，会询问浏览器是否应该给出拼写检查结果反馈。spellcheck属性需要赋值。</p><p>list特性和datalist元素<br>通过组合使用list特性和datalist元素，开发人员能够为某个输入型控件构造一张选值列表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"contactList"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"a@qq.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"b@qq.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">id</span>=<span class="string">"contatcs"</span> <span class="attr">list</span>=<span class="string">"contactList"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>min和max<br>通过设置min和max特性，可以将range输入框的数值输入范围限定在最低值和最高值之间。可以只设置一个，也可以两个都设置，也可以都不设置。</p><p>step<br>对于输入型控件，设置其step特性能够指定输入值递增或者递减的粒度。</p><p>required<br>一旦为某输入型控件设置了required特性，那么此项必填，否则无法提交表单。</p><h2 id="拖放API"><a href="#拖放API" class="headerlink" title="拖放API"></a>拖放API</h2><p>draggable属性<br>如果网页元素的draggable元素为true，这个元素就是可以拖动的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span>Draggable Div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>拖放事件<br>拖动过程会触发很多事件，主要有下面这些：</p><p>dragstart：网页元素开始拖动时触发。<br>drag：被拖动的元素在拖动过程中持续触发。<br>dragenter：被拖动的元素进入目标元素时触发，应在目标元素监听该事件。<br>dragleave：被拖动的元素离开目标元素时触发，应在目标元素监听该事件。<br>dragover：被拖动元素停留在目标元素之中时持续触发，应在目标元素监听该事件。<br>drap：被拖动元素或从文件系统选中的文件，拖放落下时触发。<br>dragend：网页元素拖动结束时触发。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">draggableElement.addEventListener(<span class="string">'dragstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'拖动开始！'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>dataTransfer对象<br>拖动过程中，回调函数接受的事件参数，有一个dataTransfer属性，指向一个对象，包含与拖动相关的各种信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">draggableElement.addEventListener(<span class="string">'dragstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.dataTransfer.setData(<span class="string">'text'</span>, <span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>dataTransfer对象的属性有：</p><p>dropEffect：拖放的操作类型，决定了浏览器如何显示鼠标形状，可能的值为copy、move、link和none。<br>effectAllowed：指定所允许的操作，可能的值为copy、move、link、copyLink、copyMove、linkMove、all、none和uninitialized（默认值，等同于all，即允许一切操作）。<br>files：包含一个FileList对象，表示拖放所涉及的文件，主要用于处理从文件系统拖入浏览器的文件。<br>types：储存在DataTransfer对象的数据的类型。<br>dataTransfer对象的方法有：</p><p>setData(format, data)：在dataTransfer对象上储存数据。第一个参数format用来指定储存的数据类型，比如text、url、text/html等。<br>getData(format)：从dataTransfer对象取出数据。<br>clearData(format)：清除dataTransfer对象所储存的数据。如果指定了format参数，则只清除该格式的数据，否则清除所有数据。<br>setDragImage(imgElement, x, y)：指定拖动过程中显示的图像。默认情况下，许多浏览器显示一个被拖动元素的半透明版本。参数imgElement必须是一个图像元素，而不是指向图像的路径，参数x和y表示图像相对于鼠标的位置。</p><h3 id="Web-Workers-API"><a href="#Web-Workers-API" class="headerlink" title="Web Workers API"></a>Web Workers API</h3><p>Javascript是单线程的。因此，持续时间较长的计算，回阻塞UI线程，进而导致无法在文本框中填入文本，单击按钮等，并且在大多数浏览器中，除非控制权返回，否则无法打开新的标签页。该问题的解决方案是Web Workers，可以让Web应用程序具备后台处理能力，对多线程的支持性非常好。</p><p>但是在Web Workers中执行的脚本不能访问该页面的window对象，也就是Web Workers不能直接访问Web页面和DOM API。虽然Web Workers不会导致浏览器UI停止响应，但是仍然会消耗CPU周期，导致系统反应速度变慢。</p><h3 id="Web-Storage-API"><a href="#Web-Storage-API" class="headerlink" title="Web Storage API"></a>Web Storage API</h3><p>Web Storage是html5引入的一个非常重要的功能，可以在客户端本地存储数据，类似html4的cookie，但可实现功能要比cookie强大的多。</p><h5 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h5><p>sessionStorage将数据保存在session中，浏览器关闭数据就消失。</p><h5 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h5><p>localStorage则一直将数据保存在客户端本地，除非手动删除，否则一直保存。<br>不管是sessionStorage，还是localStorage，可使用的API相同，常用的有如下几个（以localStorage为例）：</p><p>保存数据：localStorage.setItem(key,value);<br>读取数据：localStorage.getItem(key);<br>删除单个数据：localStorage.removeItem(key);<br>删除所有数据：localStorage.clear();<br>得到某个索引的key：localStorage.key(index);</p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS自适应布局总结教程</title>
      <link href="/2019/11/17/CSS%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93%E6%95%99%E7%A8%8B/"/>
      <url>/2019/11/17/CSS%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="这可能是史上最全的CSS自适应布局总结教程"><a href="#这可能是史上最全的CSS自适应布局总结教程" class="headerlink" title="这可能是史上最全的CSS自适应布局总结教程"></a>这可能是史上最全的CSS自适应布局总结教程</h3><p>所谓布局，其实包含两个含义：尺寸与定位。也就是说，所有与尺寸和定位相关的属性，都可以用来布局。</p><p>大体上，布局中会用到的有：尺寸相关的盒子模型，普通流、浮动、绝对定位三种定位机制，CSS3中的transform、弹性盒子模块、试验中的grid模块。逛园子的时候经常可以看到浮动布局，inline-block布局，弹性盒布局这几个名词。现在对布局也算有一点了解，做个总结巩固一下。如果你也看了很多资料，但是实际动手时对布局还是无从下手的话，希望本文可以帮你理清思路。</p><p>唠叨一句：看到一个效果图的时候，千万不要急着手贱去敲代码！先思考清楚页面的构造，理清各元素之间的关系，特别需要注意的是在不同的设备下需要有怎样的展现，当你思路清晰找到最好的布局方案时，coding其实真的不需要多少时间。</p><h2 id="尺寸相关"><a href="#尺寸相关" class="headerlink" title="尺寸相关"></a>尺寸相关</h2><p>为什么要先说尺寸呢？因为尺寸在布局中的作用非常核心，布局方式定位这些只是改变了元素之间的关系，没有尺寸就什么也不是。比如我们通常会用margin来控制跟其他元素的距离，这就是布局。</p><p>很多人都会觉得，什么width、margin太简单了，早就掌握了。这种心态我一开始学习CSS的时候也有，觉得很好理解很简单，但是后面才发现自己原来很多东西都没真正掌握。看看张鑫旭大神给我们上的政治课：<a href="http://www.zhangxinxu.com/wordpress/2012/07/bottleneck-css-study/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2012/07/bottleneck-css-study/</a> </p><p>先说说百分比，百分比是相对父对象的，这里特性非常好用，很多时候会用在自适应布局上面。浏览器尺寸的改变，就是根节点html的长宽改变，我们可以用%来将浏览器尺寸和元素尺寸联系起来，做到自适应。</p><p>另外一个比较有意思的是auto，auto是很多尺寸值的默认值，也就是由浏览器自动计算。首先是块级元素水平方向的auto，块级元素的margin、border、padding以及content宽度之和等于父元素width。使用auto属性在父元素宽度变化的时候，该元素的宽度也会随之变化。</p><img src="https://images2015.cnblogs.com/blog/933778/201604/933778-20160422153325538-411305977.jpg"><p>但是当该元素被设为浮动时，该元素的width就变成了内容的宽度了，由内容撑开，也就是所谓的有了包裹性。overflow | position:absolute | float:left/right都可以产生包裹性，替换元素也同样具有包裹性。在具有包裹性的元素上想利用width : auto；来让元素宽度自适应浏览器宽是不行的。</p><img src="https://images2015.cnblogs.com/blog/933778/201604/933778-20160422153326538-861607441.jpg"><p>高度方向：外边距重叠，外边距auto为0，这两点需要注意。书写方向什么的，接触比较少就不扯了。</p><p>那为什么margin：auto对不能计算垂直方向的值呢？很简单，垂直方向是被设计成可以无限扩展的，内容越多浏览器便产生滚动条来扩展，所以垂直方向都找不到一个计算基准，以此返回一个false，便成了0。</p><p>用处：通过width、height控制大小，各个方向的margin值控制与边界或者其他元素的距离来定位。</p><p>浮动</p><p>目前PC网站大多使用float布局，从成本上考虑大改的概率很小，所以不要说浮动无用，总是会有机会让你维护的！代表网站：淘宝、腾讯、百度，好吧BAT都到齐了。</p><p>浮动听得多了，博客园上关于用浮动布局的介绍也非常的多。浮动原本用于文本环绕，但却在布局被发扬光大，这就是命！我的理解：浮动布局的核心就是让元素脱离普通流，然后使用width/height，margin/padding将元素定位。脱离普通流的元素，就像脱离地心引力一样，与普通流不在一个高度上。这个跟图层的概念类似。高度不同所以可以叠在其他元素上面产生重叠或者使用负边距跑到父元素外，理解了这一点浮动布局就很好理解了。</p><img src="https://images2015.cnblogs.com/blog/933778/201604/933778-20160422153327507-1666485195.jpg"><p> View Code<br>原理非常简单，左右侧边栏定宽并浮动，中部内容区放最后不浮动、默认width：auto并设置相应外边距，让左右侧边栏浮动到上面。注意：子元素设置为浮动之后，父对象的高度就坍塌了，需要设置父对象后的元素清除浮动，这样父对象的高度才能被浮动子元素撑起来了。</p><p>当然，我们也要问一下，为啥父对象高度会坍塌呢？上面也说过了，浮动元素已经脱离了普通流，父对象所在的普通流比喻成地表，那浮动元素就已经上天了。但是父对象还在地表啊，从外太空看浮动元素在父对象里面，但是其实并不在，又怎么能撑开父对象呢？宽度如果我们不设置的话，其实也是为0的，因为父对象里面空空如也，所以宽高为0。</p><p>上天</p><p>要撑开的办法就两个，1是让父对象也上天（。。。你咋不上天呢），2是把浮动元素的边框边界拉下来。</p><p>父对象也上天（即浮动）的话，那就不能实现宽度自适应了。因为float元素的width：auto是包裹内容的，参考前面说的！</p><p>办法2就是在后面的元素里加一个clear语句。说到这个问题就要扯到clear与BFC了，我就不献丑了。传送门：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear</a></p><p>这个三列布局还有个双飞（是双飞翼！想啥呢）的变种，就是在HTML中center部分也就是内容区提到最前面，也就是内容先行渲染。在网络不好的时候，左右双翼能不能出来不要紧，先让主体内容出来！这种想法，明显的优秀工程师思维，但，尼玛的双翼都是广告啊。广告不出来，哪能赚钱养你们这群工程师？所以提出双飞的玉伯才离开了淘宝？？？（纯属意淫，如真属实，当我扯淡，哈哈哈！）</p><p>哈哈哈</p><p>先上码：</p><p> View Code<br>思路：</p><p>1)既然HTML里面要让center放前面，为了让left跑到center前面，那center也必须浮动了，否则因为都是块元素他们会分两行。</p><p>2)浮动之后还要让center宽度自适应，那明显width只能100%，然后在父元素中设width:auto，还有两侧margin，其实也就是父对象宽度自适应，center只是继承content的宽度。</p><p>3)对left使用负的margin让他们浮动到上方去。</p><p>代码里面我用到了一个calc()，这个CSS3带来的计算函数简直酷毙了！本例里如果不使用calc函数，那么就需要wrap左边距为0，left左边距-100%，然后center多加一层子块DIV设置margin-left：100px，可以达到同样的效果！calc函数与百分比配合就足以实现自适应的要求！目前所有的自适应布局都在利用浏览器来为我们计算尺寸，但是有了calc之后我们就可以自己制定规则！单是想想都高潮了吧？</p><p>总结：使用浮动来进行布局，一个比较大的问题是清除浮动。这个可以使用一个after伪类来清除。更大的问题是浮动性像水一样向上流动，难以把握。在元素较多而且元素高度尺寸不一的情况下，单纯使用浮动只能实现上端对齐，这对于适应多种设备的布局就显得力不从心了。目前的做法是牺牲一部分内容，将元素做成等高排列，从美观上看也当然也是极好的，比参差不齐的排列要美观。</p><p>普通流布局</p><p>普通流布局：display : inline-block！这是一个传说中取代float布局的存在。看了一些网站，PC端浮动为主，移动端的也用的不多啊，已经有些使用flex的了，说好的inline-block一统江湖呢？</p><p>使用inline-block之前先处理点小障碍：inline-block元素会有4px左右的空隙，这个是因为我们写代码时候的换行符所致。</p><p>4px间隙</p><p>解决办法很简单：在inline-block的父元素中设置样式font-size：0；letter-spacing: -4px; 然后设置inline-block的所有兄弟元素 font-size：值；letter-spacing: 值px;  恢复正常的显示。</p><p>消除4px间隙</p><p>另外还有一点需要注意的是inline-block默认是基线对齐的，而inline-block的基线又跟文本基线一致，所以在内容不同的时候并不能水平对齐。只需要用vertical-align显式声明一下top/bottom/middle对齐即可。这里补充一下基线的内容，没你想的那么简单哦。分有文字和无文字两种情况：</p><p>1）无文字：容器的margin-bottom下边缘。与容器内部的元素没一毛钱关系。</p><p>2）有文字：最后一行文字的下边缘，跟文字块（p,h等）的margin、padding没关系！注意是最后一行，无论文字在什么子对象容器内在什么位置都没关系，浏览器会找到最后一行文字对齐底部。</p><p>你们感受一下：</p><p>baseline-01    baseline-02    baseline-03</p><p>警示：inline-block的基线是最后一行文字的底部，flex里面的基线是第一行文字的底部（请看下文阮老师的文章）</p><p>baseline-04</p><p>满满的都是泪啊。。。既然都叫baseline，何必呢？</p><p>ohmygod</p><p>使用inline-block进行圣杯布局：</p><p> View Code<br>这里也没什么好说的，用到的也是width：auto和width：100%这两点，简单知识点的简单用法。</p><p>双飞的话，代码跟圣杯的基本相同，注意在html的顺序变为center&gt;right&gt;left，只改左栏移动的margin-left: calc(-100% - 100px)到预定位置即可。不能用calc的话可以在center里面再加一层，跟浮动一样的处理方式。更简单的方法是使用CSS3带给我们的box-sizing属性。请看代码：</p><p> View Code<br>总结：相比浮动inline-block更加容易理解，也更符合我们的认知，结合盒子模型的几个控制属性就可以进行布局了。对于元素高度不同的情况，目前浮动布局的做法都是将元素做成等高元素进行展现，这从美学上看也符合整齐的要求，不过牺牲了一部分内容。但inline-block有vertical-align属性，可以很好地解决元素高度不同而带来的布局问题。用过之后，你也会喜欢上inline-block的。。。至少我会！</p><p>绝对定位</p><p>前面的浮动和普通流中其实定位都是靠盒子模型控制的，与我们常说的定位还是有差别的。而绝对定位就是我们平常所说的定位，给定参考坐标系+坐标确定位置。关于绝对定位的资料太多，我就不说了。提一点就是absolute定位的基准是最近的非static定位父对象，而fixed是相对html根节点的定位。两种定位都会脱离普通流，跟之前说的浮动一样，上天了。</p><p>上天</p><p>当然，他们跟浮动在空间中的位置还是有差别的，项目中有遇到这个问题的请参考张大婶的文章： <a href="http://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/</a>  还是要结合项目来看，否则看过也只是看过而已，并不会存到你的脑子里，毕竟还是相当抽象相当理论性的东西。借用张大神的一个总结图：</p><p>2016-01-07_223349</p><p>使用绝对定位（特指absolute）做自适应布局跟前面两种方式没太大差别，宽度自适应还是在auto和100%上做文章，而位置则由top/bottom/left/right等控制。还是以圣杯布局来举例：</p><p> View Code<br>父元素为relative，子元素为absolute，这样的话，又会出现跟浮动一样的问题：父对象高度坍塌，子元素不能撑起父对象。原因也跟浮动一样，解决办法的话目前我知道的只有给父对象指定一个确定height值，大家如果有更好的办法，请联系我！</p><p>总结：单纯使用绝对定位进行自适应布局的情况很少，一般绝对定位都用在尺寸固定的元素定位上。而且fixed定位的渲染效率很低，因为它会频繁触发浏览器的重排。另外提一点：CSS3的transform会对绝对定位产生影响哦~比如说让fixed定位不再固定在浏览器视窗的黑魔法：<a href="http://www.zhangxinxu.com/wordpress/2015/05/css3-transform-affect/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2015/05/css3-transform-affect/</a> </p><p>弹性盒子</p><p>CSS3中对布局影响最大的莫过于弹性盒子模块了，这是一套区别于以往盒子模型布局的全新方案。上面几种方法你可以看到，为了实现自适应我们用的都是width：auto和100%的嵌套以及各种边距的移动定位，这套规则并不符合我们的认知。为什么不能开拓出一块区域，横竖排列都可以，内部所有元素的尺寸可以按照一个规则和这个区域的大小联系起来？终于CSS3做出了改变，引入了flex弹性布局方案，弹性盒布局有如下优势：<br>       1.独立的高度控制与对齐。<br>       2.独立的元素顺序。<br>       3.指定元素之间的关系。<br>       4.灵活的尺寸与对齐方式。</p><p>在MDN上有非常简单易懂的基础教程：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes</a></p><p>flexbox</p><p>上面也已经给出了圣杯布局的自适应布局方案，所以代码就不贴了不过这个例子实现的是3栏成比例缩放，左右栏如果需要固定值的话可以写成  flex: 0 0 150px; 的样式。</p><p>但是上面的教程没有给出各个属性的详细解释，建议看看阮一峰的博文，详细易懂而且配图超漂亮的有木有：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p><p>总结：弹性盒子在移动端的应用会越来越普遍，这套模型值得去好好研究。语法规则都是非常贴近人性，非常灵活，浏览器兼容性也非常好，当然国内百花齐放的移动浏览器会有哪些大坑呢？我们拭目以待~</p><p>其他</p><p>其他包括position：relative和CSS3中的transform都可以实现定位，但是由于他们在原来的普通流中还占着一个坑，所以很少用来布局啥的。transform是个很酷炫的东西，可以用平面的素材做出很多3D的效果，而且不需要js就可以做，非常好玩。此文已经很长，就不多说了，以后会写一篇文章来专门说说她的故事。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WEB前端知识体系精简</title>
      <link href="/2019/11/17/WEB%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E7%AE%80/"/>
      <url>/2019/11/17/WEB%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E7%AE%80/</url>
      
        <content type="html"><![CDATA[<h3 id="WEB前端知识体系精简"><a href="#WEB前端知识体系精简" class="headerlink" title="WEB前端知识体系精简"></a>WEB前端知识体系精简</h3><p>Web前端技术由<strong>html、css和 javascript</strong>三大部分构成，是一个庞大而复杂的技术体系，其复杂程度不低于任何一门后端语言。而我们在学习它的时候往往是先从某一个点切入，然后不断地接触和学习新的知识点，因此对于初学者很难理清楚整个体系的脉络结构。本文将对Web前端知识体系进行简单的梳理，对应的每个知识点点到为止，不作详细介绍。目的是帮助大家审查自己的知识结构是否完善，如有遗漏或不正确的地方，希望共勉。</p><h3 id="一、JAVASCRIPT-篇"><a href="#一、JAVASCRIPT-篇" class="headerlink" title="一、JAVASCRIPT 篇**"></a>一、JAVASCRIPT 篇**</h3><p><strong>0、基础语法</strong></p><p>Javascript 基础语法包括：变量声明、数据类型、函数、控制语句、内置对象等。</p><p>在ES5 中，变量声明有两种方式，分别是  var 和 function ，var<br>用于声明普通的变量，接收任意类型，function用于声明函数。另外，ES6 新增了 let、const、import 和 class<br>等四个命令，分别用以声明 普通变量、静态变量、模块 和 类 。</p><p>JS数据类型共有六种，分别是 String、Number、Boolean、Null、Undefined 和 Object 等， 另外，ES6新增了<br>Symbol 类型。其中，Object 是引用类型，其他的都是原始类型(Primitive Type)。</p><p>原始类型也称为基本类型或简单类型，因为其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈(stack)中(按值访问)。为了便于操作这类数据，ECMAScript<br>提供了 3 个 基本包装类型 ：Boolean、Number 和 String<br>。基本包装类型是一种特殊的引用类型，每当读取一个基本类型值的时候，JS内部就会创建一个对应的包装对象，从而可以调用一些方法来操作这些数据。</p><p>引用类型由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此其存储在堆(heap)中，存储在变量处的值是一个指针，指向存储对象的内存处(按址访问)，对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法；但基本类型不可以添加属性和方法。</p><p>Javascript 可以通过 typeof 来判断原始数据类型，但不能判断引用类型，要知道引用类型的具体类型，需要通过 Object 原型上的<br>toString 方法来判断。</p><p>JS中的函数存在着三种角色：普通函数、构造函数、对象方法。同一个函数，调用方式不同，函数的作用不一样，所扮演的角色也不一样。直接调用时就是普通函数，通过new创建对象时就是构造函数，通过对象调用时就是方法。</p><p>JS常用的内置对象有window、Date、Array、JSON、RegExp<br>等，window是浏览器在执行脚本时创建的一个全局对象，主要描述浏览器窗口相关的属性和状态，这个后面会讲到，Date 和 Array<br>使用场景最多，JSON主要用于对象的序列化和反序列化，还有一个作用就是实现对象的深拷贝。RegExp 即正则表达式，是处理字符串的利器。</p><p><strong>1、函数原型链</strong></p><p>JS是一种基于对象的语言，但在ES6 之前是不支持继承的，为了具备继承的能力，Javascript 在 <strong>函数对象</strong><br>上建立了原型对象prototype，并以函数对象为主线，从上至下，在JS内部构建了一条 <strong>原型链</strong> 。原型链把一个个独立的对象联系在一起，Object<br>则是所有对象的祖宗， 任何对象所建立的原型链最终都指向了Object，并以 Object 终结。 ****</p><p>简单来说就是建立了变量查找机制，当访问一个对象的属性时，先查找对象本身是否存在，如果不存在就去该对象所在的原型连上去找，直到Object对象为止，如果都没有找到该属性才会返回undefined。因此，我们可以通过原型链来实现JS继承。</p><p><strong>2、函数作用域</strong></p><p>函数作用域就是变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。因此， <strong>JS中没有块级作用域，只有函数作用域</strong><br>，这种设计导致JS中出现了 <strong>变量提升</strong> 的问题。简单来说就是，将变量声明提升到它所在作用域的最开始的部分，为了解决变量提升带来的副作用，ES6新增了<br>let 命令来声明变量，let 所声明的变量只在 let 命令所在的代码块内有效，所以不存在变量提升问题。</p><p><strong>3、this 指针</strong></p><p>this 指针存在于函数中，用以标识函数运行时所处的上下文。函数的类型不同，this指向规则也不一样：对于普通函数，this<br>始终指向全局对象window；对于构造函数，this则指向新创建的对象；对于方法，this指向调用该方法的对象。另外，Function对象也提供了call、apply<br>和 bind 等方法来改变函数的 this 指向，其中，call 和 apply 主动执行函数，bind一般在事件回调中使用，而 call 和 apply<br>的区别只是参数的传递方式不同。</p><p>如果往深的去理解，无论什么函数，this是否被改变， 本质上，this 均指向触发函数运行时的那个对象。而在函数运行时，this 的值是不能被改变的。</p><p><strong>4、new 操作符</strong></p><p>函数的创建有三种方式，即 显式声明、匿名定义 和 new Function()<br>。前面提到，JS中的函数即可以是函数，也可以是方法，还可以是构造函数。当使用new来创建对象时，该函数就是构造函数，JS将新对象的原型链指向了构造函数的原型对象，于是就在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型prototype中的方法和属性。</p><p><strong>5、闭包</strong></p><p>通俗来讲，闭包是一个具有独立作用域的静态执行环境。和函数作用域不同的是，闭包的作用域是静态的，可以永久保存局部资源，而函数作用域只存在于运行时，函数执行结束后立即销毁。因此，闭包可以形成一个独立的执行过程，关于闭包更</p><p><strong>6、单线程和异步队列</strong></p><p>Javascript<br>是单线程语言，在浏览器中，当JS代码被加载时，浏览器会为其分配一个主线程来执行任务(函数)，主线程会形成一个全局执行环境，执行环境在栈中采用后进先出(LIFO)的顺序来执行代码块，以保证所有的函数能按照正确的顺序被执行。</p><p>但在浏览器中，有一些任务是非常耗时的，比如ajax请求、定时器、事件等，为了保证非耗时任务不受影响，Javascript<br>在执行环境中维护了一个异步队列(也叫工作线程)，并将这些耗时任务放入队列中进行等待，这些任务的执行时机并不确定，只有当主线程的任务执行完成以后，主线程才会去检查异步队列中的任务是否需要开始执行。</p><p>JS中的 setTimeout 和 setInterval 就是典型的异步操作，它们会被放入异步队列中等待，即使 setTimeout(0)<br>也不会被立即执行，需要等到当前同步任务结束后才会被执行。</p><p><strong>7、异步通信 Ajax技术</strong></p><p>Ajax是浏览器专门用来和服务器进行交互的异步通讯技术，其核心对象是XMLHttpRequest，通过该对象可以创建一个Ajax请求。Ajax请求是一个耗时的异步操作，当请求发出以后，Ajax<br>提供了两个状态位来描述请求在不同阶段的状态，这两个状态位分别是 <strong>readyState</strong> 和 <strong>status</strong> ，readyState 通过<br>5个状态码来描述一个请求的5个阶段：</p><p>0 - 请求未发送，初始化阶段</p><p>1 - 请求发送中，服务器还未收到请求</p><p>2 - 请求发送成功，服务器已收到请求</p><p>3 - 服务器处理完成，开始响应请求，传输数据</p><p>4 - 客户端收到请求，并完成了数据下载，生成了响应对象</p><p>status 用于描述服务端对请求处理的情况，200 表示正确响应了请求，404 表示服务器找不到资源，500 代表服务器内部异常等等。</p><p>Ajax对象还可以设置一个timeout 值，代表超时时间，切记：timeout 只会影响<br>readyState，而不会影响status，因为超时只会中断数据传输，但不会影响服务器的处理结果。 如果 timeout 设置的不合理，就会导致响应码<br>status 是200，但 response里却没有数据，这种情况就是服务器正确响应了请求，但数据的下载被超时中断了。</p><p>为了防止XSS攻击，浏览器对Ajax请求做了限制，不允许Ajax 跨域请求服务器，只允许请求和当前地址同域的服务器资源。但不限制脚本和标签发送跨域请求，比如<br>script 和 img 标签，因此可以利用脚本跨域能力来实现跨域请求，即JSONP 的原理。</p><p>JSONP虽然可以解决跨域问题，但只能是get请求，并且没有有效的错误捕获机制，为了解决这个问题，XMLHttpRequest Level2 提出了<br>CORS 模型，即 <strong>跨域资源共享，</strong> 它不是一个新的API，而是一个标准规范，当浏览器发现该请求需要跨域时，就会自动在头信息中添加一个 Origin<br>字段，用以说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。 </p><p>随着移动端的快速发展，Web技术的应用场景正在变得越来越复杂， <strong>关注点分离</strong> 原则在系统设计层面就显得越来越重要，而XMLHttpRequest 是<br>Ajax 最古老的一个接口，因而不太符合现代化的系统设计理念。因此，浏览器提供了一个新的 Ajax 接口，即 <strong>Fetch API</strong> ，Fetch<br>API 是基于Promise 思想设计的，更符合关注点分离原则。</p><p><strong>8、模块化</strong></p><p>历史上，Javascript 规范一直没有模块(module)体系，即无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。在 ES6<br>之前，为了实现JS模块化编程，社区制定了一些模块加载方案，最主要有 CMD 和 AMD 两种，分别以commonjs 和 requirejs为代表。ES6<br>在语言标准的层面上，实现了模块化编程，其设计思想是，尽量静态化，使得编译时就能确定模块的依赖关系，即编译时加载，而CMD和AMD是在运行时确定依赖关系，即运行时加载。</p><p><strong>9、Node.js</strong></p><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript<br>运行环境，它的运行不依赖于浏览器作为宿主环境，而是和服务端程序一样可以独立的运行，这使得JS编程第一次从客户端被带到了服务端，Node.js在服务端的优势是，它采用单线程和异步I/O模型，实现了一个高并发、高性能的运行时环境。相比传统的多线程模型，Node.js实现简单，并且可以减少资源开销。</p><p><strong>10、ES6</strong></p><p>ES6 是 ECMAScript 6.0<br>的简写，即Javascript语言的下一代标准，已经在2015年6月正式发布了，它的目标是让JS能够方便的开发企业级大型应用程序，因此，ES6的一些规范正在逐渐向Java、C#等后端语言标准靠近。ES6<br>规范中，比较重大的变化有以下几个方面：</p><p>新增 let、const 命令 来声明变量，和var 相比，let<br>声明的变量不存在变量提升问题，但没有改变JS弱类型的特点，依然可以接受任意类型变量的声明；const<br>声明的变量不允许在后续逻辑中改变，提高了JS语法的严谨性。</p><p>新增解构赋值、rest语法、箭头函数，这些都是为了让代码看起来更简洁，而包装的语法糖。</p><p>新增模块化，这是JS走向规范比较重要的一步，让前端更方便的实现工程化。</p><p>新增类和继承的概念，配合模块化，JS也可以实现高复用、高扩展的系统架构。</p><p>新增模板字符串功能，高效简洁，结束拼接字符串的时代。</p><p>新增Promise对象，解决异步回调多层嵌套的问题。</p><h3 id="二、CSS-篇"><a href="#二、CSS-篇" class="headerlink" title="二、CSS 篇**"></a>二、CSS 篇**</h3><p><strong>1、CSS选择器</strong></p><p>CSS选择器即通过某种规则来匹配相应的标签，并为其设置CSS样式，常用的有类选择器、标签选择器、ID选择器、后代选择器、群组选择器、伪类选择器(before/after)、兄弟选择器(+~)、属性选择器等等。</p><p><strong>2、CSS Reset</strong></p><p>HTML<br>标签在不设置任何样式的情况下，也会有一个默认的CSS样式，而不同内核浏览器对于这个默认值的设置则不尽相同，这样可能会导致同一套代码在不同浏览器上的显示效果不一致，而出现兼容性问题。因此，在初始化时，需要对常用标签的样式进行初始化，使其默认样式统一，这就是CSS<br>Reset ，即CSS样式重置，比如：<em>{margin:0,padding:0} 就是最简单CSS Reset， 关于CSS重置请参考：<br>*Neat.css</em></p><p><strong>3、盒子布局</strong></p><p>盒子模型是CSS比较重要的一个概念，也是CSS 布局的基石。<br>常见的盒子模型有块级盒子(block)和行内盒子(inline-block)，与盒子相关的几个属性有：margin、border、padding和content<br>等，这些属性的作用是设置盒子与盒子之间的关系以及盒子与内容之间的关系。其中，只有普通文档流中块级盒子的垂直外边距才会发生合并，而行内盒子、浮动盒子或绝对定位之间的外边距不会合并。另外，box-sizing<br>属性的设置会影响盒子width和height的计算。</p><p><strong>4、浮动布局</strong></p><p>设置元素的 float 属性值为 left 或<br>right，就能使该元素脱离普通文档流，向左或向右浮动。一般在做宫格布局时会用到，如果子元素全部设置为浮动，则父元素是塌陷的，这时就需要清除浮动，清除浮动的方法也很多，常用的方法是在元素末尾加空元素设置clear:both，<br>更高级一点的就给父容器设置before/after来模拟一个空元素，还可以直接设置overflow属性为auto/hidden来清除浮动。除浮动可以实现宫格布局，行内盒子(inline-block)和table也可以实现同样的效果。</p><p><strong>5、定位布局</strong></p><p>设置元素的position属性值为 relative/absolute/fixed，就可以使该元素脱离文档流，并以某种参照坐标进行偏移。其中，releave<br>是相对定位，它以自己原来的位置进行偏移，偏移后，原来的空间不会被其他元素占用；absolute<br>是绝对定位，它以离自己最近的定位父容器作为参照进行偏移；为了对某个元素进行定位，常用的方式就是设置父容器的poistion:relative，因为相对定位元素在不设置<br>top 和 left 值时，不会对元素位置产生影响；fixed<br>即固定定位，它则以浏览器窗口为参照物，PC网页底部悬停的banner一般都可以通过fixed定位来实现，但fixed属性在移动端有兼容性问题，因此不推荐使用，可替代的方案是：绝对定位+内部滚动。</p><p><strong>6、弹性布局</strong></p><p>弹性布局即Flex布局，定义了flex的容器一个可伸缩容器，首先容器本身会根据容器中的元素动态设置自身大小；然后当Flex容器被应用一个大小时（width和height），将会自动调整容器中的元素适应新大小。Flex容器也可以设置伸缩比例和固定宽度，还可以设置容器中元素的排列方向（横向和纵向）和是否支持元素的自动换行。有了这个神器，做页面布局的可以方便很多了。注意，设为Flex布局以后，子元素的float、clear和vertical-align<br>属性将失效。</p><p><strong>7、CSS3 动画</strong></p><p>CSS3中规范引入了两种动画，分别是 transition 和 animation，transition<br>可以让元素的CSS属性值的变化在一段时间内平滑的过渡，形成动画效果，为了使元素的变换更加丰富多彩，CSS3还引入了transfrom<br>属性，它可以通过对元素进行 平移(translate)、旋转(rotate)、放大缩小(scale)、倾斜(skew)<br>等操作，来实现2D和3D变换效果。transiton 还有一个结束事件<br>transitionEnd，该事件是在CSS完成过渡后触发，如果过渡在完成之前被移除，则不会触发transitionEnd 。</p><p>animation 需要设置一个@keyframes，来定义元素以哪种形式进行变换，<br>然后再通过动画函数让这种变换平滑的进行，从而达到动画效果，动画可以被设置为永久循环演示。设置 animation-play-state:paused<br>可以暂停动画，设置 animation-fill-mode:forwards<br>可以让动画完成后定格在最后一帧。另外，还可以通过JS监听animation的开始、结束和重复播放时的状态，分别对应三个事件，即<br>animationStart、animationEnd、animationIteration 。注意，当播放次数设置为1时，不会触发<br>animationIteration 。</p><p>和 transition相比，animation 设置动画效果更灵活更丰富，还有一个区别是：transition<br>只能通过主动改变元素的css值才能触发动画效果，而animation一旦被应用，就开始执行动画。另外，HTML5 还新增了一个动画API，即<br>requestAnimationFrame，它通过JS来调用，并按照屏幕的绘制频率来改变元素的CSS属性，从而达到动画效果。</p><p><strong>8、BFC</strong></p><p>BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素。比如：内部滚动就是一个BFC，当一个父容器的overflow-y设置为auto时，并且子容器的长度大于父容器时，就会出现内部滚动，无论内部的元素怎么滚动，都不会影响父容器以外的布局，这个父容器的渲染区域就叫BFC。满足下列条件之一就可触发BFC：</p><p>根元素，即HTML元素</p><p>float的值不为none</p><p>overflow的值不为visible</p><p>display的值为inline-block、table-cell、table-caption</p><p>position的值为absolute或fixed</p><p><strong>9、Sprite，Iconfont，@font-face</strong></p><p>对于大型站点，为了减少http请求的次数，一般会将常用的小图标排到一个大图中，页面加载时只需请求一次网络，<br>然后在css中通过设置background-position来控制显示所需要的小图标，这就是Sprite图。</p><p>Iconfont，即字体图标，就是将常用的图标转化为字体资源存在文件中，通过在CSS中引用该字体文件，然后可以直接用控制字体的css属性来设置图标的样式，字体图标的好处是节省网络请求、其大小不受屏幕分辨率的影响，并且可以任意修改图标的颜色。</p><p>@font-face是CSS3中的一个模块，通过@font-face可以定义一种全新的字体，然后就可以通过css属性font-family来使用这个字体了，即使操作系统没有安装这种字体，网页上也会正常显示出来。</p><p><strong>10、CSS Hack</strong></p><p>早期，不同内核浏览器对CSS属性的解析存在着差异，导致显示效果不一致，比如 margin<br>属性在ie6中显示的距离会比其他浏览器中显示的距离宽2倍，也就是说margin-left:20px;在ie6中距左侧元素的实际显示距离是40px，而在非ie6的浏览器上显示正常。因此，如果要想让所有浏览器中都显示是20px的宽度，就需要在CSS样式中加入一些特殊的符号，让不同的浏览器识别不同的符号，以达到应用不同的CSS样式的目的，这种方式就是css<br>hack， 对于ie6中的margin应用hack就会变成这样：.el {margin-left:20px;_margin-left:10px}</p><p>兼容各大浏览器的 css hack 如下：</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><h3 id="三、HTML-篇"><a href="#三、HTML-篇" class="headerlink" title="三、HTML 篇**"></a>三、HTML 篇**</h3><p><strong>1、BOM</strong></p><p>BOM 是 Browser Object Model<br>的缩写，即浏览器对象模型，当一个浏览器页面初始化时，会在内存创建一个全局的对象，用以描述当前窗口的属性和状态，这个全局对象被称为浏览器对象模型，即BOM。BOM的核心对象就是window，window<br>对象也是BOM的顶级对象，其中包含了浏览器的 6个核心模块：</p><p><strong>document</strong> -<br>即文档对象，渲染引擎在解析HTML代码时，会为每一个元素生成对应的DOM对象，由于元素之间有层级关系，因此整个HTML代码解析完以后，会生成一个由不同节点组成的树形结构，俗称DOM树，document<br>用于描述DOM树的状态和属性，并提供了很多操作DOM的API。</p><p><strong>frames</strong> - HTML 子框架，即在浏览器里嵌入另一个窗口，父框架和子框架拥有独立的作用域和上下文。</p><p><strong>history</strong> - 以栈(FIFO)的形式保存着页面被访问的历史记录，页面前进即入栈，页面返回即出栈。</p><p><strong>location</strong> - 提供了当前窗口中加载的文档相关信息以及一些导航功能。</p><p><strong>navigator</strong> - 用来描述浏览器本身，包括浏览器的名称、版本、语言、系统平台、用户特性字符串等信息。</p><p><strong>screen</strong> - 提供了浏览器显示屏幕的相关属性，比如显示屏幕的宽度和高度，可用宽度和高度。</p><p><strong>2、DOM 系统</strong></p><p>DOM 是 Document Object Model 的缩写，即 文档对象模型，是所有浏览器公共遵守的标准，DOM<br>将HTML和XML文档映射成一个由不同节点组成的树型结构，俗称DOM树。其核心对象是document，用于描述DOM树的状态和属性，并提供对应的DOM操作API。随着历史的发展，DOM<br>被划分为1级、2级、3级，共3个级别：</p><p><strong>1级DOM</strong> - 在1998年10月份成为W3C的提议，由DOM核心与DOM<br>HTML两个模块组成。DOM核心能映射以XML为基础的文档结构，允许获取和操作文档的任意部分。DOM<br>HTML通过添加HTML专用的对象与函数对DOM核心进行了扩展。</p><p><strong>2级DOM</strong> - 鉴于1级DOM仅以映射文档结构为目标，DOM<br>2级面向更为宽广。通过对原有DOM的扩展，2级DOM通过对象接口增加了对鼠标和用户界面事件（DHTML长期支持鼠标与用户界面事件）、范围、遍历（重复执行DOM文档）和层叠样式表（CSS）的支持。同时也对DOM<br>1的核心进行了扩展，从而可支持XML命名空间。</p><p><strong>3级DOM</strong> -<br>通过引入统一方式载入和保存文档和文档验证方法对DOM进行进一步扩展，DOM3包含一个名为“DOM载入与保存”的新模块，DOM核心扩展后可支持XML1.0的所有内容，包括XML<br>Infoset、 XPath、和XML Base。</p><p>浏览器对不同级别DOM的支持情况如下所示：</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/34uGBxmCntrkbyHbzf5JfzNG6FOXsdQ71xppPbXr4Fr7cI6dkHSKj58U72az4oH4ykXxMJIzdwJbEANjZ7yGpw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p><p>从图中可以看出，移动端常用的 webkit 内核浏览器目前只支持DOM2，而不支持DOM3 。</p><p><strong>3、事件系统</strong></p><p>事件是用户与页面交互的基础，到目前为止，DOM事件从PC端的 鼠标事件(mouse) 发展到了 移动端的 触摸事件(touch) 和<br>手势事件(guesture)，touch事件描述了手指在屏幕操作的每一个细节，guesture 则是描述多手指操作时更为复杂的情况，总结如下：</p><p>第一根手指放下，触发 touchstart，除此之外什么都不会发生</p><p>手指滑动时，触发touchmove</p><p>第二根手指放下，触发 gesturestart</p><p>触发第二根手指的 touchstart</p><p>立即触发 gesturechange</p><p>任意手指移动，持续触发 gesturechange</p><p>第二根手指弹起时，触发 gestureend，以后将不会再触发 gesturechange</p><p>触发第二根手指的 touchend</p><p>触发touchstart (多根手指在屏幕上，提起一根，会刷新一次全局touch) _ ___</p><p>弹起第一根手指，触发 touchend</p><p>更多关于手势事件的介绍请参考：<br><em>gesture事件处理复杂手势</em></p><p>DOM2.0 模型将事件处理流程分为三个阶段，即 <strong>事件捕获阶段</strong> 、 <strong>事件处理阶段</strong> 、 <strong>事件冒泡阶段，</strong> 如图所示：</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/34uGBxmCntrkbyHbzf5JfzNG6FOXsdQ78ibdibVdnlWWHGErf7KnnRmfyFMYIgSJgrTWshV7pt7jWorD5UficZQFg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1" alt="img"></p><p><strong>事件捕获</strong> ：当用户触发点击事件后，顶层对象document 就会发出一个事件流，从最外层的DOM节点向目标元素节点传递，最终到达目标元素。</p><p><strong>事件处理</strong> ：当到达目标元素之后，执行目标元素绑定的处理函数。如果没有绑定监听函数，则不做任何处理。</p><p><strong>事件冒泡</strong> ：事件流从目标元素开始，向最外层DOM节点传递，途中如果有节点绑定了事件处理函数，这些函数就会被执行。</p><p>利用事件冒泡原理可以实现 <strong>事件委托</strong><br>，所谓事件委托，就是在父元素上添加事件监听器，用以监听和处理子元素的事件，避免重复为子元素绑定相同的事件。当目标元素的事件被触发以后，这个事件就从目标元素开始，向最外层元素传递，最终冒泡到父元素上，父元素再通过event.target<br>获取到这个目标元素，这样做的好处是，父元素只需绑定一个事件监听，就可以对所有子元素的事件进行处理了，从而减少了不必要的事件绑定，对页面性能有一定的提升。</p><h3 id="HTML解析过程"><a href="#HTML解析过程" class="headerlink" title="HTML解析过程"></a>HTML解析过程</h3><p>浏览器加载 html 文件以后，渲染引擎会从上往下，一步步来解析HTML标签，大致过程如下：</p><p>用户输入网址，浏览器向服务器发出请求，服务器返回html文件；</p><p>渲染引擎开始解析 html 标签，并将标签转化为DOM节点，生成 DOM树；</p><p>如果head 标签中引用了外部css文件，则发出css文件请求，服务器返回该文件，该过程会阻塞后面的解析；</p><p>如果引用了外部 js 文件，则发出 js 文件请求，服务器返回后立即执行该脚本，这个过程也会阻塞html的解析；</p><p>引擎开始解析 body 里面的内容，如果标签里引用了css 样式，就需要解析刚才下载好的css文件，然后用css来设置标签的样式属性，并生成渲染树；</p><p>如果 body 中的 img 标签引用了图片资源，则立即向服务器发出请求，此时引擎不会等待图片下载完毕，而是继续解析后面的标签；</p><p>服务器返回图片文件，由于图片需要占用一定的空间，会影响到后面元素的排版，因此引擎需要重新渲染这部分内容；</p><p>如果此时 js 脚本中运行了 style.display=”none”，布局被改变，引擎也需要重新渲染这部分代码；</p><p>直到 html 结束标签为止，页面解析完毕。</p><p><strong>5、重绘 和 回流</strong></p><p>当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。比如上面的img文件加载完成后就会引起回流，每个页面至少需要一次回流，就是在页面第一次加载的时候。</p><p>当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘。</p><p>从上面可以看出，回流必将引起重绘，而重绘不一定会引起回流。会引起重绘和回流的操作如下：</p><p>添加、删除元素(回流+重绘)</p><p>隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流)</p><p>移动元素，比如改变top,left的值，或者移动元素到另外一个父元素中。(重绘+回流)</p><p>对style的操作(对不同的属性操作，影响不一样)</p><p>还有一种是用户的操作，比如改变浏览器大小，改变浏览器的字体大小等(回流+重绘)</p><p>另外，transform<br>操作不会引起重绘和回流，是一种高效率的渲染。这是因为transform属于合成属性，对合成属性进行transition/animation<br>动画时将会创建一个合成层，这使得动画元素在一个独立的层中进行渲染，当元素的内容没有发生改变，就没必要进行重绘，浏览器会通过重新复合来创建动画帧。</p><p><strong>6、本地存储</strong></p><p>本地存储最原始的方式就是 cookie,cookie 是存放在本地浏览器的一段文本，数据以键值对的形式保存，可以设置过期时间。 但是 cookie<br>不适合大量数据的存储，因为每请求一次页面，cookie 都会发送给服务器，这使得 cookie<br>速度很慢而且效率也不高。因此cookie的大小被限制为4k左右(不同浏览器可能不同,分HOST)，如下所示：</p><p>Firefox和Safari允许cookie多达4097个字节，包括名(name)、值(value) 和 等号。</p><p>Opera允许cookie多达4096个字节，包括：名(name)、值(value) 和 等号。</p><p>Internet Explorer允许cookie多达4095个字节，包括：名(name)、值(value) 和 等号。</p><p><strong>在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。</strong></p><p>html5 提供了两种在客户端存储数据的新方法：localStorage 和 sessionStorage, 它们都是以key/value<br>的形式来存储数据，前者是永久存储，后者的存储期限仅限于浏览器会话(session)，即当浏览器窗口关闭后，sessionStorage中的数据被清除。</p><p>localStorage的存储空间大约5M左右(不同浏览器可能不同，分<br>HOST)，这个相当于一个5M大小的前端数据库，相比于cookie，可以节约带宽，但localStorage在浏览器隐私模式下是不可读取的，当存储数据超过了localStorage<br>的存储空间后会抛出异常。</p><p>此外，H5还提供了逆天的websql和<br>indexedDB，允许前端以关系型数据库的方式来存储本地数据，相对来说，这个功能目前应用的场景比较少，此处不作介绍。</p><p><strong>7、浏览器缓存机制</strong></p><p>浏览器缓存机制是指通过 HTTP 协议头里的 Cache-Control (或 Expires) 和 Last-Modified (或 Etag)<br>等字段来控制文件缓存的机制。</p><p>Cache-Control 用于控制文件在本地缓存有效时长。最常见的，比如服务器回包：Cache-Control:max-age=600<br>表示文件在本地应该缓存，且有效时长是600秒 (从发出请求算起)。在接下来600秒内，如果有请求这个资源，浏览器不会发出 HTTP<br>请求，而是直接使用本地缓存的文件。</p><p>Last-Modified 是标识文件在服务器上的最新更新时间。下次请求时，如果文件缓存过期，浏览器通过 If-Modified-Since<br>字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否有修改。如果没有修改，服务器返回304告诉浏览器继续使用缓存；如果有修改，则返回200，同时返回最新的文件。</p><p>Cache-Control 通常与 Last-Modified 一起使用。一个用于控制缓存有效时间，一个在缓存失效后，向服务查询是否有更新。</p><p>Cache-Control 还有一个同功能的字段：Expires。Expires 的值一个绝对的时间点，如：Expires: Thu, 10 Nov<br>2015 08:45:11 GMT，表示在这个时间点之前，缓存都是有效的。</p><p>Expires 是 HTTP1.0 标准中的字段，Cache-Control 是 HTTP1.1<br>标准中新加的字段，功能一样，都是控制缓存的有效时间。当这两个字段同时出现时，Cache-Control 是高优化级的。</p><p>Etag 也是和 Last-Modified 一样，对文件进行标识的字段。不同的是，Etag<br>的取值是一个对文件进行标识的特征字串。在向服务器查询文件是否有更新时，浏览器通过 If-None-Match<br>字段把特征字串发送给服务器，由服务器和文件最新特征字串进行匹配，来判断文件是否有更新。没有更新回包304，有更新回包200。Etag 和<br>Last-Modified 可根据需求使用一个或两个同时使用。两个同时使用时，只要满足基中一个条件，就认为文件没有更新。</p><p>另外有两种特殊的情况：</p><p>手动刷新页面(F5)，浏览器会直接认为缓存已经过期(可能缓存还没有过期)，在请求中加上字段：Cache-Control:max-age=0，发包向服务器查询是否有文件是否有更新。</p><p>强制刷新页面(Ctrl+F5)，浏览器会直接忽略本地的缓存(有缓存也会认为本地没有缓存)，在请求中加上字段：Cache-Control:no-cache<br>(或 Pragma:no-cache)，发包向服务重新拉取文件。</p><p><strong>8、History</strong></p><p>用户访问网页的历史记录通常会被保存在一个类似于栈的对象中，即history对象，点击返回就出栈，跳下一页就入栈。 它提供了以下方法来操作页面的前进和后退：</p><p>window.history.back( )  返回到上一个页面</p><p>window.history.forward( )  进入到下一个页面</p><p>window.history.go( [delta] )  跳转到指定页面</p><p>HTML5 对History Api 进行了增强，新增了两个Api 和一个事件，分别是pushState、replaceState 和<br>onpopstate：</p><p>pushState是往history对象里添加一个新的历史记录，即压栈。</p><p>replaceState 是替换history对象中的当前历史记录。</p><p>当点击浏览器后退按钮或 js调用history.back 都会触发 onpopstate 事件。</p><p>与其类似的还有一个事件：onhashchange，onhashchange是老API，浏览器支持度高，本来是用来监听hash变化的，但可以被利用来做客户端前进和后退事件的监听，而onpopstate是专门用来监听浏览器前进后退的，不仅可以支持hash，非hash的同源<br>url 也支持。</p><p><strong>9、HTML5离线缓存</strong></p><p>HTML5离线缓存又叫Application<br>Cache，是从浏览器的缓存中分出来的一块缓存区，如果要在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。</p><p>manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。manifest 文件可分为三个部分：</p><p>- CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</p><p>- NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</p><p>- FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</p><p>离线缓存为应用带来三个优势：</p><p>离线浏览 - 用户可在应用离线时使用它们</p><p>速度 - 已缓存资源加载得更快</p><p>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</p><p><strong>10、Web语义化 和 SEO</strong></p><p>Web语义化是指使用语义恰当的标签，使页面有良好的结构，页面元素有含义，能够让人和搜索引擎都容易理解。</p><p>SEO是指在了解搜索引擎自然排名机制的基础之上，对网站进行内部及外部的调整优化，改进网站在搜索引擎中关键词的自然排名，获得更多的展现量，吸引更多目标客户点击访问网站，从而达到互联网营销及品牌建设的目标。</p><p>搜索引擎通过爬虫技术获取的页面就是由一堆 html 标签组成的代码，人可以通过可视化的方式来判断页面上哪些内容是重点，而机器做不到。<br>但搜索引擎会根据标签的含义来判断内容的权重，因此，在合适的位置使用恰当的标签，使整个页面的语义明确，结构清晰，搜索引擎才能正确识别页面中的重要内容，并予以较高的权值。比如h1~h6这几个标签在SEO中的权值非常高，用它们作页面的标题就是一个简单的SEO优化。</p>]]></content>
      
      
      <categories>
          
          <category> Web概述 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React</title>
      <link href="/2019/11/16/React/"/>
      <url>/2019/11/16/React/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>用于构建用户界面的 JavaScript 库, 它是FaceBook的一个开源项目</p><p>它的设计模式为Javascript MV* 框架 (MVC/MVVM/MVP/MV<em>), 无论是哪种MV*</em>系列，都涉及到了Model和View，如果单纯的只有Model和View，他们是没有办法一起协同工作的，所以就有了各种MV..的设计模式</p><p>它是 针对UI层的Web-webApp应用方案</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>组件化开发+模块化开发</li><li>高效的虚拟DOM</li><li>前后端通吃的WebApp框架  (Vue前端框架, Nuxtjs)</li><li>跨平台运行(React-native) (甚至可以产出iOS的android的应用)  (Flutter)</li><li>庞大的React生态系统 (比vuejs的插件多的多)(它是一个国外的项目)  (而且北京3年以上react的多一些)</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>相比Vuejs, 学习曲线陡峭</li><li>需要一定的前端开发经验(小程序/vuejs/angularjs/js基础更好)</li><li>设计思想与方式有所不同</li></ol><h3 id="全家桶"><a href="#全家桶" class="headerlink" title="全家桶"></a>全家桶</h3><ol><li>react基础语法</li><li>webpack+nodejs基础</li><li>react-router (React里的路由) (react-router-dom)</li><li>Redux (实际开发用: React-Redux) (相当于Vuex)</li><li>create-react-app (React的官方脚手架)</li><li>网络请求的框架 — axios, 以及转发代理— (http-proxy-middleware)</li></ol><h3 id="学完能干啥"><a href="#学完能干啥" class="headerlink" title="学完能干啥"></a>学完能干啥</h3><p>可以成吨的提高开发效率, 开发移动端/PC端/兼容前后台的页面和不同设备的项目</p><h3 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h3><p>React 起源于 Facebook 的内部项目, 他从最早的UI引擎变成了一整套前后端通吃的, Web App 解决方案。衍生的 React Native(React语法) 项目, 目标更是宏伟，希望用写 Web App 的方式去写 Native App (iOS(OC)和Android(JAVA+VS)。如果能够实现，整个互联网行业都会被颠覆，因为同一组人只需要写一次 UI ，就能同时运行在服务器、浏览器和手机。</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><ol><li><p>引入react.js和react-dom.js, 如果使用jsx语法, 需要再引入babel.js</p><ul><li>react-dom.js 处理跟DOM相关的操作, 暴露对象为ReactDOM</li><li>babel.js 是为了将jsx语法, 通过babel编译成ES5的代码运行在浏览器中</li></ul></li><li><p>声明根标签(用于指定虚拟DOM挂载的位置)</p></li><li><p>在script标签上, 声明JSX语法, type=”text/babel”</p><ul><li>JSX是一种JavaScript的语法扩展，运用于<a href="https://baike.baidu.com/item/React/18077599" target="_blank" rel="noopener">React</a>架构中，其格式比较像是模版语言，但事实上完全是在<a href="https://baike.baidu.com/item/JavaScript/321142" target="_blank" rel="noopener">JavaScript</a>内部实现的。元素是构成React应用的最小单位，JSX就是用来声明React当中的元素，React使用JSX来描述用户界面。</li></ul></li><li><p>ReactDOM.render(), 把虚拟DOM挂载到哪个标签身上, 给用户查看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"./build/react-0.14.0.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"./build/react-dom-0.14.0.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"./build/browser.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"text/babel"</span>&gt;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">&lt;h1&gt;Hello World!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">) <span class="comment">// render()方法用于渲染页面, 参数1: React根标签, 参数2: 目标位置</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意: 在浏览器中是无法识别react中的jsx语法糖，采用babel实现jsx语法转化es5语法</p></blockquote><h3 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h3><ol><li><p>HTML 中使用 JS, 用大括号</p></li><li><p>在render内, 只能有一个根标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userName = <span class="string">"react"</span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;以天为被&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;h3&gt;&#123;username&#125;&lt;/</span>h3&gt;</span><br><span class="line">            &lt;h1&gt;以地为床&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;,</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li></ol><h3 id="数组使用"><a href="#数组使用" class="headerlink" title="数组使用"></a>数组使用</h3><ol><li>需要给每个循环的标签, 添加key属性, 而且值是唯一的</li><li>在JSX的HTML当中, 直接返回夹着数据的标签即可</li></ol><h3 id="属性使用"><a href="#属性使用" class="headerlink" title="属性使用"></a>属性使用</h3><ol><li>原生的class -&gt; className 代替</li><li>原生的for属性 -&gt;  htmlFor 代替</li><li>单标签, 最后一定要加上 /</li><li>属性都采用 驼峰 标识 (比如原生事件onclick, 就要写成onClick)</li></ol><blockquote><p>JSX语法一定要严格, 因为它比较死板</p></blockquote><blockquote><p>动态class: className={obj[‘later’] ? ‘success’ : ‘error’}</p></blockquote><h3 id="方法使用"><a href="#方法使用" class="headerlink" title="方法使用"></a>方法使用</h3><ol><li>在JS中ReactDOM.render()之外定义方法</li><li>在JSX语法标签模板中, {方法名()} 使用即可</li><li>方法里可以返回标签/返回标签数组/用于事件的方法上</li></ol><blockquote><p>事件都要使用驼峰标识, 跟原生onclick有些差别</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;fnThree&#125;&gt;点我点我&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><h2 id="标签创建"><a href="#标签创建" class="headerlink" title="标签创建"></a>标签创建</h2><p>这里只是创建一个标签对象, 不是组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">React.createElement() 方法</span><br><span class="line"><span class="comment">// 参数1: 标签名</span></span><br><span class="line">    <span class="comment">// 参数2: 标签属性 (是个对象)</span></span><br><span class="line">    <span class="comment">// 参数3: 此标签的内容 (可以理解为innerHTML)</span></span><br><span class="line">    <span class="keyword">let</span> titleCom = React.createElement(</span><br><span class="line">        <span class="string">"p"</span>,</span><br><span class="line">        &#123;<span class="string">"className"</span>: <span class="string">'title_p'</span>&#125;,</span><br><span class="line">        <span class="string">"Hello, React"</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h2 id="组件创建"><a href="#组件创建" class="headerlink" title="组件创建"></a>组件创建</h2><ol><li><p>React.createClass({})</p></li><li><p>构造函数function 组件名(){}</p></li><li><p>class 组件名 extends React.Component  (组件名要大写)</p></li><li><p>如果向组件内传值</p><ul><li><p>组件内直接使用 this.props.变量名</p></li><li><p>使用组件的地方, 直接用变量名=传值 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">组件内使用:</span><br><span class="line">&lt;p&gt;子组件接收到的值是:  --- &#123;<span class="keyword">this</span>.props.myTitle&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">传值</span></span><br><span class="line"><span class="regexp">&lt;MyTr myTitle=&#123;'你好啊'&#125; /</span>&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>组件嵌套使用: 其实就是在组件内直接使用 另外一个组件</p></li></ol><h2 id="动态style"><a href="#动态style" class="headerlink" title="动态style"></a>动态style</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=&#123;&#123;color: &apos;red&apos;&#125;&#125;&gt;我是动态的style&lt;/p&gt;</span><br><span class="line">&lt;p style=&#123;&#123;color: &quot;yellow&quot;, backgroundColor: &quot;blue&quot;&#125;&#125;&gt;如果多对用逗号隔开&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">// 最外层的大括号: 代表这里是JS的代码</span><br><span class="line">// 内层的大括号: 代表这是CSS样式的对象</span><br></pre></td></tr></table></figure><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><h3 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h3><ol><li>JS中 使用标签, 直接使用&lt;&gt; 声明标签</li><li>如果在JS的html标签中, 要写JS代码, 需要使用 {} 扩起来</li><li>大括号内, 可以使用变量/表达式/三目运算/数组 (但是不能直接写入一个对象{name: ‘人名’})</li><li>如果返回一堆标签, 可以用数组装着, 然后在{} 直接使用数组变量即可</li><li>在map循环时候, 返回一个个标签, 组成一个数组, 然后使用</li><li>在JSX中, class和for是关键字, 所以<ul><li>class -&gt; className</li><li>for -&gt; htmlFor (label标签)</li><li>都要使用驼峰标识</li></ul></li></ol><h3 id="速查表"><a href="#速查表" class="headerlink" title="速查表"></a>速查表</h3><table><thead><tr><th>方法/属性名</th><th>解析</th><th>备注</th></tr></thead><tbody><tr><td>ReactDOM.render()</td><td>把虚拟DOM渲染到指定的真实标签中</td><td>2个参数, 参数1只能有一个根标签</td></tr><tr><td>React.createElement()</td><td>创建一个在内存中的虚拟DOM标签</td><td>3个参数, <br />参数1: 标签名, <br />参数2: 属性和值(最好是一个对象格式) <br />参数3: 此标签的内容….(可以是标签/字符串/多个)</td></tr><tr><td>React.createClass()</td><td>创建一个组件(类似于自定义标签)</td><td>注意1: 组件名一定要大写字母开头 注意2: 参数是一个对象 注意3: 在render函数中return 一个根标签(是组件要被渲染的标签)</td></tr><tr><td>构造函数创建组件</td><td></td><td>注意1: 没有render, 直接return 一个根标签就可以了</td></tr><tr><td>class xxx extends React.Component {}</td><td>常用在创建React组件的地方</td><td>注意1: 要使用render() 来返回根标签 注意2: 在父-&gt;子传值时, 直接定义变量名, 使用时this.props.变量名即可 直接使用</td></tr></tbody></table><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol><li>react中类组件和函数组件不同?</li></ol><p>import { React } from ‘react’<br>var App = (){<br>return()<br>}<br>类组件：<br>import { React,Component } from ‘react’<br>class App extends Component{<br>render(){<br>return()<br>}<br>}<br>函数组件无state和生命周期，传值需要用props<br>类组件有state和生命周期，传值需要this.props </p><ol start="2"><li><p>JSX是什么? 浏览器怎么解析JSX</p><p>JSX 将 HTML 语法直接加入到 JavaScript 代码中，再通过翻译器转换到纯 JavaScript 后由浏览器执行。在实际开发中，JSX 在产品打包阶段都已经编译成纯 JavaScript，不会带来任何副作用，反而会让代码更加直观并易于维护。<br>浏览器中通过给script标签添加type=”text/bable”属性来解析jsx</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初识Vue</title>
      <link href="/2019/11/15/%E5%88%9D%E8%AF%86Vue/"/>
      <url>/2019/11/15/%E5%88%9D%E8%AF%86Vue/</url>
      
        <content type="html"><![CDATA[<h4 id="阶段要学习的内容"><a href="#阶段要学习的内容" class="headerlink" title="阶段要学习的内容"></a>阶段要学习的内容</h4><ol><li>Vuejs 基础语法</li><li>Vue-router (前端路由组件)</li><li>Vuex (全局状态管理器)</li><li>axios (可用在前端/Node的请求模块)</li><li>Vue-cli2 (vue2.x) 脚手架模板</li><li>组件库的学习</li></ol><h4 id="简介-What"><a href="#简介-What" class="headerlink" title="简介(What)"></a>简介(What)</h4><p>​    它是一个渐进式的前端框架, 底层还是封装的原生JS </p><p>​    渐进式: 由底向上逐级开发组件, 增量开发, 构成我们的应用</p><p><img src="D:%5Czg%E6%96%87%E6%A1%A3%5C%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5_%E5%A4%87%E8%AF%BE_%E6%9D%8E%E4%B8%9C%E6%97%AD%5Cday03_vue01%5C%E7%A4%BA%E4%BE%8B%5C%E6%B8%90%E8%BF%9B%E5%BC%8F%E8%AE%B2%E8%A7%A3.png" alt="渐进式讲解"></p><h4 id="为什么学-Why"><a href="#为什么学-Why" class="headerlink" title="为什么学?(Why)"></a>为什么学?(Why)</h4><p>​    Vuejs的速度一目了然, 容错性很高. 成吨的提高你的开发效率, 极大减少了你操作DOM的动作, 只需要关系数据和视图即可</p><p>​    原生Javascript:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul id=<span class="string">"myUl"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">let</span> arr = [<span class="string">"春天"</span>, <span class="string">"夏天"</span>, <span class="string">"秋天"</span>, <span class="string">"冬天"</span>];</span><br><span class="line">        <span class="keyword">let</span> myUl = <span class="built_in">document</span>.getElementById(<span class="string">"myUl"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> theLi = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">            theLi.innerHTML = arr[i];</span><br><span class="line">            myUl.appendChild(theLi);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure><p>​    Vue实现同样效果:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;ul&gt;<span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in arr"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    new Vue(&#123;</span></span><br><span class="line"><span class="regexp">        el: "#app",</span></span><br><span class="line"><span class="regexp">        data: &#123;arr: ["春天", "夏天", "秋天", "冬天"]&#125;</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>​    原生js好比锯条, jq好比是带把手的锯条, vuejs电锯</p><h4 id="怎么学-How"><a href="#怎么学-How" class="headerlink" title="怎么学?(How)"></a>怎么学?(How)</h4><ol><li><p>要有html+css+javascript的基础</p><ol start="2"><li>以及Vuejs的基础语法 (不建议上来就用VueCli脚手架)</li><li>NodeJS+Webpack的基础</li><li>VueJS路由学习</li><li>VueCli脚手架的学习和使用 (熟悉VueCli里的各项配置)</li><li>Vuex+脚手架里使用路由+网络请求库+组件库的学习</li></ol></li></ol><h4 id="VueJS注意事项"><a href="#VueJS注意事项" class="headerlink" title="VueJS注意事项"></a>VueJS注意事项</h4><ol><li>不兼容IE8及以下IE浏览器</li><li>建议安装vue的devtool工具, 帮助你进行调试代码</li><li>必须是vuejs编写的代码, 才可以在控制台使用vue调试工具</li></ol><h4 id="安装devTool工具"><a href="#安装devTool工具" class="headerlink" title="安装devTool工具"></a>安装devTool工具</h4><ol><li>下载: 官网(<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a>) -&gt; 生态系统 -&gt; devTool工具</li><li>我们下载的是Google Chrome浏览器的插件 -&gt; 打开谷歌浏览器 -&gt; 更多工具 -&gt; 扩展程序</li><li>打开开发者模式, 把下载好的插件文件夹 -&gt; 拖拽扔进去即可完成安装</li><li>注意: 插件的文件夹不要删除/也不要随意挪动</li></ol><h3 id="使用VueJS"><a href="#使用VueJS" class="headerlink" title="使用VueJS"></a>使用VueJS</h3><ol><li><p>引入vuejs的js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/vue/2.6.6/vue.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>声明根节点标签, 包裹着的都是Vuejs代码, 注意不能以html/body为根标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>实例化Vue对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el: <span class="string">"#app"</span>, <span class="comment">// 告诉vue实例, 从id叫app的标签开始, 内部都是你vue的代码</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h4><p>​    它就是vuejs里最独特的使用方式, 可以在html中直接书写JS的变量/表达式</p><p>​    js表达式: 由变量/常量+运算符 组成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123;表达式&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el: <span class="string">"#app"</span>,</span><br><span class="line">data : &#123; <span class="comment">// data里都是声明的变量</span></span><br><span class="line">    message: <span class="string">"欢迎来到vuejs的世界"</span> <span class="comment">//无需var/let, 直接书写即可!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​    注意, 声明式渲染中, 可以写入表达式代码(包括判断/运算/条件运算符)等</p><p>​    例如:</p><pre><code>&lt;p&gt;{{ message }}&lt;/p&gt;&lt;p&gt;{{ 10 + 5 }}&lt;/p&gt;&lt;p&gt;{{ grade === 10 ? '等于' : '不等于' }}&lt;/p&gt;&lt;p&gt;{{ grade > 9 }}&lt;/p&gt;</code></pre><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>​    v- 开头的, 叫做 指令, 作用: 给标签扩展更多的功能, 因为你的属性被vue的指令修饰了, 说明现在你用的是vue的东西, 所以可以直接使用, 无需再加双大括号修饰</p><h5 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h5><p>​        给标签自带的属性, 设置一个变量的值, </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-bind:title=<span class="string">"pTitle"</span>&gt;我是个可怜, 无助, 能吃的p标签&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;img :src="imgSrc" alt="" /</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h5><p>​        给标签绑定事件, 注意后面的地方直接跟方法名, 如果没有参数, 则无需写小括号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v-on:click=<span class="string">"btn"</span></span><br><span class="line">@click=<span class="string">"btn2"</span> <span class="comment">// 事件简化写法用@</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法要写在new Vue() 的methods:中</span></span><br></pre></td></tr></table></figure><h5 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h5><p>​        控制标签的出现和隐藏, 用于控制标签的 出现/隐藏 如果传true则当前标签+所有子标签都出现</p><p>​        如果传false, 则都不会出现, 但是如果有对应的v-else会显示v-else的标签</p><h5 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h5><p>​        v-else不能单独出现, 必须配合对应的v-if使用</p><h5 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h5><p>​        跟v-if的效果一样, 唯一的区别是:</p><p>​        v-if 传false 时, 不会在DOM上加载这个标签</p><p>​        v-show 传false 时, 会在DOM上加载这个标签(利用display:none;的方式隐藏</p><blockquote><p>所以用v-if和v-show取决于标签是否要频繁的切换, 如果需要则使用v-show, 效率高, 特别是包含子标签特别多的时候</p></blockquote><h5 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h5><p>​        用于根据数据, 循环生成标签, 在指令里用的是最多的</p><p>​        item: 临时变量, 每次循环, 获取的是数组里每一项的值</p><p>​        in关键字(必须)</p><p>​        arr 代表的vue里声明的变量(数组)</p><p>​        index: 临时变量, 代表下角标的使用</p><p>​        注意1: 每个循环的标签, 需要给一个独立(不重复的)key属性的值, 用来标识唯一性, 用于部分刷新和重载数据</p><p>​        注意2: v-for使用位置: 确定让哪个标签循环铺设, 就在哪个标签身上写v-for</p><p>​        注意3: v-for里的临时变量, 只能在当前标签/子标签内使用, 不能在兄弟标签上使用</p><h5 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h5><p>​        v-model主要应用于表单标签上, value属性的绑定, 实现页面标签的value值和Vuejs变量的双向绑定 (推荐使用v-model), 页面改变表单的值, 会同步给vuejs里的变量</p><blockquote><p>注意: 只有input和textarea以及select 等表单, 有v-model, 用v-model来给表单绑定值</p></blockquote><p>​        例如: 输入框/密码框/多选/下拉/单选/textarea</p><p>​        注意: 多选框的v-model必须是一个数组类型</p><blockquote><p> v-model, 实际上绑定的就是value属性</p></blockquote><h5 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h5><p>​        v-once修饰的标签, 只有在网页打开的第一次加载完, 以后就不会在受变量变化而影响</p><h4 id="事件详解"><a href="#事件详解" class="headerlink" title="事件详解"></a>事件详解</h4><p>​    在事件/属性后面.xxx 叫做修饰符, 修饰符一般都有额外的功能</p><ol><li><p>@click.stop 阻止事件冒泡</p><ol start="2"><li>@click.prevent 阻止默认事件</li><li>@click.self 只能由标签自身触发</li><li>@click.once 程序运行期间只能执行一次</li><li>@click=”btn6(myArg)” 事件传参, 如果是字符串, 请用单引号</li></ol></li></ol><blockquote><p>注意: 如果传参, 再使用(), 如果不传, 可以省略()不写, 如果传实践对象, 要使用$event</p></blockquote><h3 id="双向数据绑定原理"><a href="#双向数据绑定原理" class="headerlink" title="双向数据绑定原理"></a>双向数据绑定原理</h3><ol><li><p>页面-&gt;数据, 借助 oninput事件</p><ol start="2"><li>数据-&gt;页面, 借助Object.defineProperty() 监听一个对象的属性值的变化</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = <span class="string">""</span>; <span class="comment">// 临时存储值</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">       data.message = ev.target.value; <span class="comment">// 获取输入框里最新的值</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> data = &#123; <span class="comment">// 准备类似data里的数据</span></span><br><span class="line">       message: <span class="string">""</span></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 参数1: 监听的对象, 参数2: 监听对象里的属性名, 参数3: 固定写法</span></span><br><span class="line">   <span class="built_in">Object</span>.defineProperty(data, <span class="string">"message"</span>, &#123;</span><br><span class="line">       <span class="comment">// 当你获取data对象里的message属性值的时候, 触发get方法</span></span><br><span class="line">       <span class="comment">// 不要在get方法里直接提取data.message的值, 会造成递归调用卡死.</span></span><br><span class="line">      <span class="keyword">get</span> () &#123;</span><br><span class="line">          <span class="comment">// return到你 写data.message的地方</span></span><br><span class="line">          <span class="keyword">return</span> temp;</span><br><span class="line">      &#125;,</span><br><span class="line">       <span class="comment">// data.message =  xxx 赋值的时候, 才会触发</span></span><br><span class="line">       <span class="keyword">set</span> (val) &#123;</span><br><span class="line">           <span class="comment">// 更新页面(所有跟message变量相关的界面)</span></span><br><span class="line">           <span class="built_in">document</span>.getElementById(<span class="string">"myP"</span>).innerHTML = val;</span><br><span class="line">           <span class="built_in">document</span>.getElementById(<span class="string">"myInput"</span>).value = val;</span><br><span class="line">           <span class="comment">// 更新message的值</span></span><br><span class="line">           temp = val;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h3 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h3><p>​    Vuejs官网: <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
